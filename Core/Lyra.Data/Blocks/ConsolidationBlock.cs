using Lyra.Core.API;
using MongoDB.Bson.Serialization.Attributes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Lyra.Core.Blocks
{
    [BsonIgnoreExtraElements]
    public class ConsolidationBlock : Block
    {
        public List<string> blockHashes { get; set; }
        public string MerkelTreeHash { get; set; }
        public long totalBlockCount { get; set; }

        // fee aggregation
        public long totalFees { get; set; }

        public string createdBy { get; set; }

        public override BlockTypes GetBlockType()
        {
            return BlockTypes.Consolidation;
        }

        public override bool AuthCompare(Block other)
        {
            var ob = other as ConsolidationBlock;

            return base.AuthCompare(ob) &&
                CompareHashes(ob.blockHashes) &&
                MerkelTreeHash == ob.MerkelTreeHash &&
                totalBlockCount == ob.totalBlockCount &&
                totalFees == ob.totalFees &&
                createdBy == ob.createdBy;
        }

        private bool CompareHashes(List<String> otherHashes)
        {
            if (blockHashes.Count != otherHashes.Count)
                return false;

            var arr1 = blockHashes.ToArray();
            var arr2 = otherHashes.ToArray();
            for(var i = 0; i < blockHashes.Count; i++)
            {
                if (arr1[i] != arr2[i])
                    return false;
            }
            return true;
        }

        protected override string GetExtraData()
        {
            string nui = string.Empty;
            if (blockHashes != null && blockHashes.Count > 0)
            {
                nui = blockHashes.Aggregate(new StringBuilder(),
                          (sb, h) => sb.Append($"|{h}"),
                          sb => sb.ToString());
            }
            var str = base.GetExtraData() +
                nui +
                $"|{totalFees}" +
                $"|{MerkelTreeHash}";

            if (Version > 1)
                str += $"|{createdBy}";

            return str;
        }

        public override string Print()
        {
            string result = base.Print();
            result += $"created by leader: {createdBy}\n";
            result += $"totalBlockCount: {totalBlockCount}\n";
            result += $"totalFees: {totalFees.ToBalanceDecimal()}\n";
            result += $"MerkelTreeHash: {MerkelTreeHash}\n";
            result += $"blockHashes: {string.Join(", ", blockHashes)}\n";
            return result;
        }
    }

    // Sync block:
    // 1) allows smooth transition between authorization samples; 
    // 2) ensures that stuck transactions are cleaned up.
    // Sync block does not include any changes; the samples is taken from the latest service block.
    // Transactions that reference an old service or sync block (< height - 1) are rejected.
    // The block is generated by the authorizer with largest stake;
    // If no block is generated within 2 minutes, the authorizer with the second stake must generate it, etc.
    //public class SyncBlock : Block
    //{
    //    public string LastServiceBlockHash { get; set; }

    //    public override BlockTypes GetBlockType()
    //    {
    //        return BlockTypes.Sync;
    //    }
    //}
}
